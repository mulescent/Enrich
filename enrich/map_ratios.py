#!/usr/bin/env python
'''
map_ratios: The map_ratios module uses variant frequencies generated by map_counts to calculate enrichment ratios for each variant that occurs in both the unselected and selected map_counts output files.  

The map_ratios module also uses a two-sided Possion exact test using the R poisson.test function to calculate a p-value for the significance of enrichment or depeletion for each variant and then performs multiple testing correction using the R qvalue function to produce a q-value.  
'''

import sys, time, math, os, optparse #import general libraries
import enrich_util #import project-specific libraries


__author__ = "Douglas M. Fowler"
__copyright__ = "Copyright 2011"
__credits__ = ["Douglas M Fowler", "Carlos L. Araya"]
__license__ = "FreeBSD"
__version__ = "0.2"
__maintainer__ = "Douglas M. Fowler"
__email__ = "dfowler@uw.edu"

try: #check to see if scipy is installed
    from scipy import stats

except:
    print 'Error: SciPy not present, p-values will be reported as NaN.'

try: # check to see if qvalue found
    import qvalue as qv

except:
    print 'Error: qvalue module not found, qvalues will be reported as NaN.'
    
def twotail_ptest(x, T, r, debug_flag=False):
    '''
    A slightly more advanced version of scipy's poisson test, to compensate for a time base and a two-sided test. Uses a two-sided p-test.
    A rewrite of poisson.test for R.
    '''
    m = r * T
    try:
        # Caching of scipy functions for quick calculation
        ppois = stats.poisson.cdf
        dpois = stats.poisson.pmf
        if m == 0:
            x == 0
        else:
            relErr = 1 + 1e-7
            d = dpois(x, r * T)

            if x == m:
                return 1
            elif x < m:
                N = int(math.ceil(2 * m - x))
                while (dpois(N, m) > d):
                    N = 2 * N
                i = [index for index in xrange(int(math.ceil(m)), N+1)]
                y = len([z for z in i if dpois(z, m) <= d * relErr])
                return ppois(x, m) + (1-ppois(N-y, m))
            else:
                i = [index for index in xrange(0, int(math.floor(m) + 1))]
                y = len([z for z in i if dpois(z, m) <= d * relErr])
                return ppois(y-1, m) + (1-ppois(x - 1, m))

    except:
        return float('NaN')

def main(path, infile1, infile2, grid = 'L'):
    input_A_file = infile1
    input_B_file = infile2
    path = path

    if grid != 'L': #print logging information, if being called from the cluster
        print time.asctime(time.localtime())
        print path, infile1, infile2
        
    try:
        #build the standard dictionary for later printing:
        input_dict = enrich_util.build(path + 'data/output/' + input_A_file)
        
        #build a dictionary of the sequences and counts:
        norm_A_dict = enrich_util.build_value_dict(path + 'data/output/' + input_A_file, 0, 7, "float")
        norm_B_dict = enrich_util.build_value_dict(path + 'data/output/' + input_B_file, 0, 7, "float")
        
        count_A_dict = enrich_util.build_value_dict(path + 'data/output/' + input_A_file, 0, 8, "int")
        count_B_dict = enrich_util.build_value_dict(path + 'data/output/' + input_B_file, 0, 8, "int")
    
    except:
        print 'Error: failed to open input file(s)'
        return(1)


    sum_A_counts = sum(count_A_dict.values())
    sum_B_counts = sum(count_B_dict.values())
    
    #build a dictionary of the ratios beuence library counts:
    ratio_dict = enrich_util.gen_ratio_dict(norm_A_dict, norm_B_dict)
    poisson_dict = {}
    fdr_dict = {}
    
    try:
        for key in ratio_dict: #for each ratio, calculate the poisson exact test pvalue using scipy
            count_A = count_A_dict[key]
            B_ratio = float(count_B_dict[key]) / float(sum_B_counts)
            poisval = twotail_ptest(count_A, sum_A_counts, B_ratio)
            poisson_dict[key] = poisval
    
    except:
        print 'Error: the poisson test function caused an error.  P-values will be reported as NaN.'
        for key in ratio_dict:
            poisson_dict[key] = float('NaN')

    try: #calculate the list of qvalues given the pvalue list, using the qvalue module
        keys = poisson_dict.keys()
        sorted_pvals = []
        [sorted_pvals.append(poisson_dict[key]) for key in keys] #generate a list of sorted pvalues (order is important here)
        qvals = qv.qvalue(sorted_pvals) #perform the qvalue analysis
        qvals = qvals['qvalues']
        for i in xrange(0, len(qvals)): #create a dictionary of qvalues
            fdr_dict[keys[i]] = qvals[i] 
            
    except:
        print 'Error: the qvalue module caused an error.  Qvalues will be reported as NaN.'
        qvals = []
        keys = poisson_dict.keys()
        for key in ratio_dict:
            fdr_dict[key] = float('NaN')

    bonferroni = len(poisson_dict) #calculate the Bonferroni correction factor
    
    #print to file the sequences, ratios and other data 
    f = open(path + 'data/output/' + 'ratios_' + input_A_file.split('counts_')[1] + '_' + input_B_file.split('counts_')[1], 'w')
    f_1 = open(path + 'data/output/' + 'ratios_' + input_A_file.split('counts_')[1] + '_' + input_B_file.split('counts_')[1] + '.m1', 'w')
    f_2 = open(path + 'data/output/' + 'ratios_' + input_A_file.split('counts_')[1] + '_' + input_B_file.split('counts_')[1] + '.m2', 'w')

    print >>f, '\t'.join(["seqID","sequence","match_count","mutation_count","mutation_location","mutation_identity","max_mutation_run","log2_ratio", "fractional_fitness", "fractional_wt", "pval", "bonferroni", "qval"])
    print >>f_1, '\t'.join(["seqID","sequence","match_count","mutation_count","mutation_location","mutation_identity","max_mutation_run","log2_ratio", "fractional_fitness", "fractional_wt", "pval", "bonferroni", "qval"])
    print >>f_2, '\t'.join(["seqID","sequence","match_count","mutation_count","mutation_location","mutation_identity","max_mutation_run","log2_ratio", "fractional_fitness", "fractional_wt", "pval", "bonferroni", "qval"])
    
    seqIDs = enrich_util.valuesort(ratio_dict)
    seqIDs.reverse()
    maxRatio = ratio_dict[seqIDs[0]]
    
    try:
        wtRatio = ratio_dict['NA-NA']
        
    except:
        print 'WT not found, setting WT ratio = 1'
        wtRatio = 1
        
    for seqID in seqIDs:
        poisson = poisson_dict[seqID]
        fdr = fdr_dict[seqID]

        try:
            bf = poisson*bonferroni
            if bf > 1: #make sure Bonferroni pvalues do not exceed 1
                bf = 1
                
        except:
            bf = 'NA'
            
        print >>f, '\t'.join([seqID] + map(str, input_dict[seqID][:6] + [math.log(float(ratio_dict[seqID]),2), float(ratio_dict[seqID])/maxRatio, float(ratio_dict[seqID])/wtRatio] + [poisson, bf, fdr]))
        
        if input_dict[seqID][2] == '1':
            print >>f_1, '\t'.join([seqID] + map(str, input_dict[seqID][:6] + [math.log(float(ratio_dict[seqID]),2), float(ratio_dict[seqID])/maxRatio, float(ratio_dict[seqID])/wtRatio] + [poisson, bf, fdr]))
            
        if input_dict[seqID][2] == '2':
            print >>f_2, '\t'.join([seqID] + map(str, input_dict[seqID][:6] + [math.log(float(ratio_dict[seqID]),2), float(ratio_dict[seqID])/maxRatio, float(ratio_dict[seqID])/wtRatio] + [poisson, bf, fdr]))
            
    f.close()
    f_1.close()
    f_2.close()
    
    return(0)
    
if __name__ == '__main__':
    
    parser = optparse.OptionParser()
    parser.add_option('--path', action = 'store', type = 'string', dest = 'path', help = 'exact location from / of runLayerA, with trailing /')
    parser.add_option('--infile1', action = 'store', type = 'string', dest = 'infile1', help = 'input filename, numerator')
    parser.add_option('--infile2', action = 'store', type = 'string', dest = 'infile2', help = 'input filename, denominator')
    parser.add_option('--local', action = 'store', type = 'string', dest = 'local', help = 'Is this a local (L) run or should an SGE (SGE) job be scheduled?')
    (option, args) = parser.parse_args()

    main(option.path, option.infile1, option.infile2, option.local)
